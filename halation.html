<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Halation Studio ‚Äî Node-based Halation + Glow</title>
<style>
  :root{
    --bg:#0f1113; --panel:#16181a; --accent:#00BFA6; --muted:#9aa0a6;
    --gap:12px; --radius:10px; --card:#111318;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#e6eef1;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  .app{display:flex;flex-direction:column;height:100vh;gap:var(--gap);padding:8px;}
  header{display:flex;align-items:center;gap:8px;flex-wrap:wrap;}
  h1{font-size:14px;margin:0;font-weight:600;}
  .main{display:flex;flex:1;gap:8px;align-items:stretch;min-height:0;}
  /* canvas area */
  .canvas-wrap{flex:1;display:flex;flex-direction:column;background:linear-gradient(180deg,#0b0c0d,#0f1113);border-radius:12px;padding:6px;min-height:200px;position:relative;overflow:hidden;}
  #glcanvas{width:100%;height:100%;border-radius:8px;background:#000;touch-action:none;display:block;cursor:grab;}
  #glcanvas:active{cursor:grabbing;}
  .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap;padding:8px;background:var(--panel);border-radius:8px;justify-content:center;}
  .control-panel{width:280px;max-width:35vw;background:var(--panel);border-radius:12px;padding:8px;box-shadow:0 6px 20px rgba(0,0,0,0.6);overflow:auto;display:flex;flex-direction:column;}
  .node-card{background:var(--card);border-radius:8px;padding:8px;margin-bottom:8px;border:1px solid rgba(255,255,255,0.03)}
  .node-header{display:flex;align-items:center;justify-content:space-between;gap:6px}
  .node-title{font-weight:600;font-size:13px}
  .node-controls{margin-top:6px}
  .control-row{display:flex;flex-direction:column;gap:4px;margin-bottom:6px}
  label{font-size:12px;color:var(--muted)}
  input[type="range"]{width:100%;height:24px}
  .big-btn{background:var(--accent);color:#012;border:none;padding:8px 10px;border-radius:8px;font-weight:600;font-size:13px}
  .small-btn{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:6px;border-radius:6px;font-size:12px}
  .muted{color:var(--muted);font-size:12px}
  .row{display:flex;gap:6px;align-items:center}
  .tiny{font-size:11px;color:var(--muted)}
  select,input[type="color"]{width:100%;padding:4px;border-radius:6px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit;font-size:12px}
  .toggle{display:inline-flex;align-items:center;gap:6px}
  .icon-btn{background:transparent;border:0;color:var(--muted);padding:4px;border-radius:4px;font-size:12px}
  footer{display:flex;gap:8px;justify-content:space-between;align-items:center;font-size:11px;color:var(--muted)}
  
  /* Touch controls overlay */
  .touch-controls{position:absolute;top:8px;right:8px;display:flex;gap:4px;z-index:10;}
  .touch-btn{background:rgba(0,0,0,0.7);color:white;border:none;padding:6px;border-radius:6px;font-size:12px;min-width:32px;height:32px;display:flex;align-items:center;justify-content:center;}
  
  /* File input styling */
  .file-input-wrapper{position:relative;display:inline-block;}
  .file-input-wrapper input[type="file"]{position:absolute;opacity:0;width:100%;height:100%;cursor:pointer;}
  .file-input-btn{background:var(--accent);color:#012;border:none;padding:8px 12px;border-radius:8px;font-weight:600;font-size:13px;cursor:pointer;display:inline-block;text-align:center;min-width:80px;}
  .file-input-btn:hover{background:#00d4b8;}
  
  /* mobile-first */
  @media(max-width:768px){
    .app{padding:6px;gap:6px;}
    .main{flex-direction:column;gap:6px;}
    .canvas-wrap{min-height:250px;}
    .control-panel{width:100%;max-width:none;max-height:40vh;}
    .toolbar{justify-content:center;}
    header{justify-content:center;text-align:center;}
    h1{font-size:13px;}
    .muted{font-size:11px;}
  }
  
  @media(min-width:900px){
    .app{padding:12px}
    .control-panel{width:320px;max-width:30vw}
  }
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>Halation Studio ‚Äî Node Editor</h1>
    <div class="muted">Halation + Glow ‚Äî node-based. Reorder nodes; per-node bypass.</div>
  </header>

  <div class="main">
    <div class="canvas-wrap">
      <canvas id="glcanvas"></canvas>
      <div class="touch-controls">
        <button id="zoomInBtn" class="touch-btn" title="Zoom In">+</button>
        <button id="zoomOutBtn" class="touch-btn" title="Zoom Out">‚àí</button>
        <button id="resetViewBtn" class="touch-btn" title="Reset View">‚åÇ</button>
      </div>
    </div>
    
      <div class="toolbar">
      <div class="file-input-wrapper">
        <input id="file" type="file" accept="image/*" />
        <label for="file" class="file-input-btn">üìÅ Upload Image</label>
      </div>
        <button id="fitBtn" class="small-btn">Fit</button>
        <button id="download" class="big-btn">Download (crop)</button>
    </div>

    <aside class="control-panel" id="controls">
      <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
        <div style="flex:1">
          <div class="muted">Node Order (top = first applied)</div>
        </div>
      </div>

      <!-- Node list & controls -->
      <div id="nodesContainer"></div>

      <div style="margin-top:8px" class="muted tiny">Tip: drag is not implemented; use ‚Üë/‚Üì to reorder. The node rendered last takes priority.</div>
    </aside>
  </div>

  <footer>
    <div class="muted">Built for quick halation + glow experimentation.</div>
    <div class="muted">Open-source demo</div>
  </footer>
</div>

<script>
/* Full Node-based Halation + Glow WebGL2 app
   - Two nodes: Halation, Glow
   - Node ordering with ‚Üë ‚Üì buttons (last node applied last)
   - Per-node enable & before/after (bypass)
   - Glow: many blend modes, Resolve-accurate options available through Resolve Mode toggle
   - Halation preserved from prior working version (aspect-correct)
   Notes: optimized for clarity and to run in modern browsers with WebGL2.
*/

// --------- DOM refs ----------
const $ = id => document.getElementById(id);
const fileInput = $('file');
const fitBtn = $('fitBtn');
const downloadBtn = $('download');
const nodesContainer = $('nodesContainer');
const canvas = $('glcanvas');

// --------- GL init ----------
let gl = canvas.getContext('webgl2', { preserveDrawingBuffer: true });
if(!gl){ alert('WebGL2 required. Use a modern browser.'); throw new Error('WebGL2 required'); }

// --------- state ----------
let sourceTex = null;
let imageRect = null; // crop region in canvas pixels
let workingW = 1024, workingH = 768;
// Keep a reference to the original uploaded image and its native resolution
let originalImage = null;
let originalImageWidth = 0;
let originalImageHeight = 0;

// Canvas transformation state for touch controls
let canvasTransform = {
  scale: 1.0,
  translateX: 0.0,
  translateY: 0.0,
  minScale: 0.1,
  maxScale: 5.0
};

// Touch state
let touchState = {
  isDragging: false,
  lastTouchX: 0,
  lastTouchY: 0,
  startDistance: 0,
  startScale: 1.0
};

// We'll keep a simple shared FBO pool sized to canvas pixels
let texPool = {}; // will hold dynamically created textures/fbos per pass

// Node structure: each node has id, type, enabled, before (bypass), collapsed, settings
let nodes = [
  { id: 'halation', type: 'Halation', enabled: false, before: false, collapsed: true, settings: {
      amount: 0.6, radius: 40, threshold: 0.85, color: '#ff8b6b', iterations: 2
    }
  },
  { id: 'glow', type: 'Glow', enabled: false, before: false, collapsed: true, settings: {
      amount: 0.0, radius: 40, threshold: 0.9, color: '#ffd4b2', iterations: 2,
      blend: 'Screen', resolveMode: false
    }
  }
];

// ------- helpers: canvas sizing -------
function fitCanvas(){
  const rect = canvas.parentElement.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  const cssW = Math.max(400, Math.floor(rect.width - 16));
  const cssH = Math.max(300, Math.floor(window.innerHeight - 200));
  canvas.style.width = cssW + 'px';
  canvas.style.height = cssH + 'px';
  canvas.width = Math.floor(cssW * dpr);
  canvas.height = Math.floor(cssH * dpr);
}
fitCanvas();
window.addEventListener('resize', ()=>{ fitCanvas(); initPool(); render(); });

// ------- GL shader helpers -------
function compileShader(src, type){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
    console.error(gl.getShaderInfoLog(s));
    throw new Error('Shader compile error');
  }
  return s;
}
function linkProgram(vsSrc, fsSrc){
  const vs = compileShader(vsSrc, gl.VERTEX_SHADER);
  const fs = compileShader(fsSrc, gl.FRAGMENT_SHADER);
  const p = gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(p));
    throw new Error('Program link error');
  }
  return p;
}

// basic fullscreen quad with transformation support
const VS_QUAD = `#version 300 es
in vec2 a_pos; in vec2 a_uv; out vec2 v_uv;
uniform mat3 u_transform;
void main(){ 
  vec2 transformed = (u_transform * vec3(a_pos, 1.0)).xy;
  v_uv = a_uv; 
  gl_Position = vec4(transformed, 0.0, 1.0); 
}`;

// basic fullscreen quad without transformation (for intermediate passes)
const VS_QUAD_SIMPLE = `#version 300 es
in vec2 a_pos; in vec2 a_uv; out vec2 v_uv;
void main(){ 
  v_uv = a_uv; 
  gl_Position = vec4(a_pos, 0.0, 1.0); 
}`;

const QUAD_BUF = new Float32Array([
  -1,-1, 0,0,
   1,-1, 1,0,
  -1, 1, 0,1,
   1, 1, 1,1,
]);

let quadVAO = null;
function setupQuad(){
  quadVAO = gl.createVertexArray();
  gl.bindVertexArray(quadVAO);
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, QUAD_BUF, gl.STATIC_DRAW);
  // attributes will be enabled in bindAttributes
}
setupQuad();

function bindAttributes(prog){
  gl.bindVertexArray(quadVAO);
  // ensure buffer bound (it is bound in setupQuad but rebind to be safe)
  const pos = gl.getAttribLocation(prog, 'a_pos');
  const uv = gl.getAttribLocation(prog, 'a_uv');
  gl.enableVertexAttribArray(pos);
  gl.enableVertexAttribArray(uv);
  gl.vertexAttribPointer(pos, 2, gl.FLOAT, false, 16, 0);
  gl.vertexAttribPointer(uv, 2, gl.FLOAT, false, 16, 8);
}

// ------- shader sources (reused / composed) -------
// Mask shader (luminance threshold)
const FS_MASK = `#version 300 es
precision highp float;
in vec2 v_uv; out vec4 o;
uniform sampler2D u_tex; uniform float u_threshold;
void main(){
  vec3 c = texture(u_tex, v_uv).rgb;
  float l = dot(c, vec3(0.299,0.587,0.114));
  float mask = smoothstep(u_threshold, 1.0, l);
  o = vec4(mask,mask,mask,1.0);
}`;

// Separable blur shader (9-tap Gaussian) with pixel-true radius
const FS_BLUR = `#version 300 es
precision highp float;
in vec2 v_uv; out vec4 o;
uniform sampler2D u_tex; uniform vec2 u_texel; uniform float u_radius; uniform int u_horizontal;
float gaussian(float x, float sigma){ return exp(- (x*x) / (2.0 * sigma * sigma)); }
void main(){
  // u_radius is in pixels. Map the 9 taps across [-radius, radius] range
  float radiusPx = max(0.0, u_radius);
  float sigma = max(0.0001, radiusPx / 3.0);
  vec3 sum = vec3(0.0); float wsum = 0.0;
  for(int i=-4;i<=4;i++){
    float t = float(i);
    float px = t * (radiusPx / 4.0); // distribute taps across the pixel radius
    float w = gaussian(px, sigma);
    vec2 off = (u_horizontal==1)
      ? vec2(px * u_texel.x, 0.0)
      : vec2(0.0, px * u_texel.y);
    sum += texture(u_tex, v_uv + off).rgb * w; 
    wsum += w;
  }
  o = vec4(sum / max(wsum, 1e-6), 1.0);
}`;

// Tint the mask into colored glow/halo
const FS_TINT = `#version 300 es
precision highp float;
in vec2 v_uv; out vec4 o;
uniform sampler2D u_mask; uniform vec3 u_tint;
void main(){
  float m = texture(u_mask, v_uv).r;
  float s = pow(m, 0.9);
  o = vec4(u_tint * s, 1.0);
}`;

// Draw/composite shader: this will support multiple blend modes between base and effect texture.
// We'll implement several blend functions, with fast approximations as default and Resolve-accurate formulas available in branches.
const FS_COMPOSITE = `#version 300 es
precision highp float;
in vec2 v_uv; out vec4 o;
uniform sampler2D u_base; // input image (or previous node output)
uniform sampler2D u_effect; // effect result to blend
uniform float u_amount;
uniform int u_mode; // enum for blend mode
// modes: 0=Normal,1=Screen,2=Add,3=OverlayFast,4=SoftLightFast,5=Multiply,6=OverlayResolve,7=SoftLightResolve

vec3 blendScreen(vec3 a, vec3 b){ return 1.0 - (1.0 - a) * (1.0 - b); }
vec3 blendAdd(vec3 a, vec3 b){ return a + b; }
vec3 blendMultiply(vec3 a, vec3 b){ return a * b; }
vec3 overlayFast(vec3 a, vec3 b){ return mix(2.0*a*b, 1.0 - 2.0*(1.0-a)*(1.0-b), step(0.5,a)); }
vec3 softlightFast(vec3 a, vec3 b){
  // simple approximation
  return mix(a - (1.0 - 2.0*b) * a * (1.0 - a), a + (2.0*b - 1.0) * (sqrt(a) - a), step(0.5,b));
}

// Resolve-accurate overlay and softlight approximations based on common filmic implementations
vec3 overlayResolve(vec3 a, vec3 b){
  vec3 res;
  for(int i=0;i<3;i++){
    if(a[i] < 0.5) res[i] = 2.0*a[i]*b[i];
    else res[i] = 1.0 - 2.0*(1.0-a[i])*(1.0-b[i]);
  }
  return res;
}
vec3 softlightResolve(vec3 a, vec3 b){
  // Based on Adobe/Resolve implementation (not exact source but close behavior)
  vec3 res;
  for(int i=0;i<3;i++){
    if(b[i] < 0.5){
      res[i] = a[i] - (1.0 - 2.0*b[i]) * a[i] * (1.0 - a[i]);
    } else {
      float d;
      if(a[i] < 0.25) d = ((16.0 * a[i] - 12.0) * a[i] + 4.0) * a[i];
      else d = sqrt(a[i]);
      res[i] = a[i] + (2.0*b[i] - 1.0) * (d - a[i]);
    }
  }
  return res;
}

void main(){
  vec3 base = texture(u_base, v_uv).rgb;
  vec3 eff = texture(u_effect, v_uv).rgb;
  vec3 blended;
  if(u_mode==0){ blended = eff; } // Normal: effect replaces (but we'll mix by amount)
  else if(u_mode==1){ blended = blendScreen(base, eff); }
  else if(u_mode==2){ blended = blendAdd(base, eff); }
  else if(u_mode==3){ blended = overlayFast(base, eff); }
  else if(u_mode==4){ blended = softlightFast(base, eff); }
  else if(u_mode==5){ blended = blendMultiply(base, eff); }
  else if(u_mode==6){ blended = overlayResolve(base, eff); }
  else if(u_mode==7){ blended = softlightResolve(base, eff); }
  else { blended = eff; }
  // final mix: lerp(base, blended, amount) but preserving original brightness when amount small
  vec3 outc = mix(base, blended, clamp(u_amount, 0.0, 1.0));
  // If amount>1.0, do additive boost scaling
  if(u_amount > 1.0){
    outc = base + (blended - base) * (u_amount);
  }
  o = vec4(outc, 1.0);
}`;

// compile commonly used programs
const progMask = linkProgram(VS_QUAD_SIMPLE, FS_MASK);
const progBlur = linkProgram(VS_QUAD_SIMPLE, FS_BLUR);
const progTint = linkProgram(VS_QUAD_SIMPLE, FS_TINT);
const progComposite = linkProgram(VS_QUAD_SIMPLE, FS_COMPOSITE);
const progCompositeScreen = linkProgram(VS_QUAD, FS_COMPOSITE); // for final screen output with transform

// ------- FBO / texture pool -------
function createTex(w, h){
  const t = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, t);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  return t;
}
function createFBO(t){
  const f = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, f);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, t, 0);
  const s = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
  if(s !== gl.FRAMEBUFFER_COMPLETE) console.warn('FBO incomplete', s);
  return f;
}

function initPool(){
  // clean previous
  for(let k in texPool){
    try{ if(texPool[k].tex) gl.deleteTexture(texPool[k].tex); if(texPool[k].fbo) gl.deleteFramebuffer(texPool[k].fbo); }catch(e){}
  }
  texPool = {};
  const w = canvas.width, h = canvas.height;
  // base textures: mask, tmp, blur, tinted, nodeOut1, nodeOut2
  texPool.mask = { tex: createTex(w,h), fbo: createFBO(null) }; // we'll set fbo later
  texPool.tmp  = { tex: createTex(w,h), fbo: createFBO(null) };
  texPool.blur = { tex: createTex(w,h), fbo: createFBO(null) };
  texPool.tinted = { tex: createTex(w,h), fbo: createFBO(null) };
  texPool.nodeOutA = { tex: createTex(w,h), fbo: createFBO(null) };
  texPool.nodeOutB = { tex: createTex(w,h), fbo: createFBO(null) };
  // attach fbos properly
  texPool.mask.fbo = createFBO(texPool.mask.tex);
  texPool.tmp.fbo  = createFBO(texPool.tmp.tex);
  texPool.blur.fbo = createFBO(texPool.blur.tex);
  texPool.tinted.fbo = createFBO(texPool.tinted.tex);
  texPool.nodeOutA.fbo = createFBO(texPool.nodeOutA.tex);
  texPool.nodeOutB.fbo = createFBO(texPool.nodeOutB.tex);
}
initPool();

// ------- Bind attributes utility -------
function bindAttribs(prog){
  gl.bindVertexArray(quadVAO);
  const posLoc = gl.getAttribLocation(prog, 'a_pos');
  const uvLoc = gl.getAttribLocation(prog, 'a_uv');
  gl.enableVertexAttribArray(posLoc); gl.enableVertexAttribArray(uvLoc);
  // Bind the same quad buffer (it is already bound); set pointers
  gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 16, 0);
  gl.vertexAttribPointer(uvLoc, 2, gl.FLOAT, false, 16, 8);
}

// ------- Render utilities: mask -> blur -> tint pipeline -------
function getTransformMatrix() {
  // Create transformation matrix for canvas view
  const scale = canvasTransform.scale;
  const tx = canvasTransform.translateX / canvas.width;
  const ty = -canvasTransform.translateY / canvas.height; // Flip Y axis
  
  return new Float32Array([
    scale, 0, 0,
    0, scale, 0,
    tx, ty, 1
  ]);
}

function setTransformUniform(program) {
  const transformLoc = gl.getUniformLocation(program, 'u_transform');
  if (transformLoc) {
    gl.uniformMatrix3fv(transformLoc, false, getTransformMatrix());
  }
}

function maskPass(inputTex, threshold, outFBO){
  gl.bindFramebuffer(gl.FRAMEBUFFER, outFBO);
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.useProgram(progMask);
  bindAttribs(progMask);
  // Don't apply transform to intermediate passes
  gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, inputTex);
  gl.uniform1i(gl.getUniformLocation(progMask, 'u_tex'), 0);
  gl.uniform1f(gl.getUniformLocation(progMask, 'u_threshold'), threshold);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}
function blurSeparable(inputTex, radius, iterations){
  // ping-pong with texPool.tmp and texPool.blur. Return texPool.blur.tex as final blurred
  let rad = radius;
  for(let i=0;i<iterations;i++){
    // horizontal
    gl.bindFramebuffer(gl.FRAMEBUFFER, texPool.tmp.fbo);
    gl.viewport(0,0,canvas.width,canvas.height);
    gl.useProgram(progBlur);
    bindAttribs(progBlur);
    // Don't apply transform to intermediate passes
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, (i===0)? texPool.mask.tex : texPool.blur.tex);
    gl.uniform1i(gl.getUniformLocation(progBlur,'u_tex'), 0);
    gl.uniform2f(gl.getUniformLocation(progBlur,'u_texel'), 1.0/canvas.width, 1.0/canvas.height);
    gl.uniform1f(gl.getUniformLocation(progBlur,'u_radius'), rad);
    gl.uniform1i(gl.getUniformLocation(progBlur,'u_horizontal'), 1);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    // vertical
    gl.bindFramebuffer(gl.FRAMEBUFFER, texPool.blur.fbo);
    gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, texPool.tmp.tex);
    gl.uniform1i(gl.getUniformLocation(progBlur,'u_tex'), 0);
    gl.uniform1i(gl.getUniformLocation(progBlur,'u_horizontal'), 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    rad *= 0.6;
    // copy result into mask for next iter if multiple (not necessary; just ping/pong already)
  }
  return texPool.blur.tex;
}
function tintPass(maskTex, tintColor, outFBO){
  gl.bindFramebuffer(gl.FRAMEBUFFER, outFBO);
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.useProgram(progTint);
  bindAttribs(progTint);
  // Don't apply transform to intermediate passes
  gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, maskTex);
  gl.uniform1i(gl.getUniformLocation(progTint,'u_mask'), 0);
  gl.uniform3f(gl.getUniformLocation(progTint,'u_tint'), tintColor[0], tintColor[1], tintColor[2]);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

// composite pass using progComposite
function compositePass(baseTex, effectTex, amount, mode, outFBO){
  gl.bindFramebuffer(gl.FRAMEBUFFER, outFBO);
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.useProgram(progComposite);
  bindAttribs(progComposite);
  // Don't apply transform to intermediate passes
  gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, baseTex);
  gl.uniform1i(gl.getUniformLocation(progComposite,'u_base'), 0);
  gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, effectTex);
  gl.uniform1i(gl.getUniformLocation(progComposite,'u_effect'), 1);
  gl.uniform1f(gl.getUniformLocation(progComposite,'u_amount'), amount);
  gl.uniform1i(gl.getUniformLocation(progComposite,'u_mode'), mode);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

// ------- Node renderers -------
// Each node takes an input texture and returns an output texture (texture object).
// We'll alternate outputs into nodeOutA / nodeOutB textures to chain.

function renderHalationNode(inputTex, settings){
  // 1) mask from inputTex -> texPool.mask
  maskPass(inputTex, parseFloat(settings.threshold), texPool.mask.fbo);
  // 2) blur mask -> texPool.blur (multi-iter)
  const blurred = blurSeparable(texPool.mask.tex, parseFloat(settings.radius), parseInt(settings.iterations));
  // 3) tint -> texPool.tinted
  const hex = settings.color.replace('#','');
  const r = parseInt(hex.substring(0,2),16)/255;
  const g = parseInt(hex.substring(2,4),16)/255;
  const b = parseInt(hex.substring(4,6),16)/255;
  tintPass(blurred, [r,g,b], texPool.tinted.fbo);
  // 4) composite: base=inputTex, effect=texPool.tinted -> out to nodeOutA
  compositePass(inputTex, texPool.tinted.tex, parseFloat(settings.amount), 2, texPool.nodeOutA.fbo); // use Add(2) for halation default additive look
  return texPool.nodeOutA.tex;
}

function renderGlowNode(inputTex, settings){
  // 1) mask threshold from inputTex -> texPool.mask
  maskPass(inputTex, parseFloat(settings.threshold), texPool.mask.fbo);
  // 2) blur mask into texPool.blur
  const blurred = blurSeparable(texPool.mask.tex, parseFloat(settings.radius), parseInt(settings.iterations));
  // 3) tint blurred mask into texPool.tinted
  const hex = settings.color.replace('#','');
  const r = parseInt(hex.substring(0,2),16)/255;
  const g = parseInt(hex.substring(2,4),16)/255;
  const b = parseInt(hex.substring(4,6),16)/255;
  tintPass(blurred, [r,g,b], texPool.tinted.fbo);
  // 4) decide blend mode mapping (strings to u_mode ints)
  const modeMapFast = {
    'Normal':0, 'Screen':1,'Add':2,'Overlay (Fast)':3,'SoftLight (Fast)':4,'Multiply':5
  };
  const modeMapResolve = {
    'Overlay (Resolve)':6,'SoftLight (Resolve)':7
  };
  let mode = 0;
  if(settings.resolveMode && (settings.blend in modeMapResolve)) mode = modeMapResolve[settings.blend];
  else if(settings.blend in modeMapFast) mode = modeMapFast[settings.blend];
  else {
    // fallback mapping: try general names
    mode = modeMapFast[settings.blend] || 1;
  }
  // composite: base=inputTex, effect=texPool.tinted -> out to nodeOutB
  compositePass(inputTex, texPool.tinted.tex, parseFloat(settings.amount), mode, texPool.nodeOutB.fbo);
  return texPool.nodeOutB.tex;
}

// ------- Main pipeline runner -------
function runPipelineAndDraw(){
  if(!sourceTex){
    // clear
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0,0,canvas.width,canvas.height);
    gl.clearColor(0,0,0,1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    return;
  }
  
  // Check if any nodes are enabled
  const hasEnabledNodes = nodes.some(node => node.enabled && !node.before);
  
  // Start with sourceTex as current
  let currentTex = sourceTex;
  
  // We'll iterate nodes in order, applying enabled nodes. Each node writes to its assigned nodeOut (A or B)
  for(let i=0;i<nodes.length;i++){
    const node = nodes[i];
    if(!node.enabled){
      // bypass: pass-through to next node (we can copy by rendering inputTex into nodeOut)
      compositePass(currentTex, currentTex, 0.0, 0, (i%2===0)? texPool.nodeOutA.fbo : texPool.nodeOutB.fbo);
      currentTex = (i%2===0)? texPool.nodeOutA.tex : texPool.nodeOutB.tex;
      continue;
    }
    if(node.before){ // per-node before/after: show before (bypass the effect)
      compositePass(currentTex, currentTex, 0.0, 0, (i%2===0)? texPool.nodeOutA.fbo : texPool.nodeOutB.fbo);
      currentTex = (i%2===0)? texPool.nodeOutA.tex : texPool.nodeOutB.tex;
      continue;
    }
    // active node: render according to type
    if(node.type === 'Halation'){
      currentTex = renderHalationNode(currentTex, node.settings);
    } else if(node.type === 'Glow'){
      currentTex = renderGlowNode(currentTex, node.settings);
    } else {
      // unknown node -> pass through
      compositePass(currentTex, currentTex, 0.0, 0, (i%2===0)? texPool.nodeOutA.fbo : texPool.nodeOutB.fbo);
      currentTex = (i%2===0)? texPool.nodeOutA.tex : texPool.nodeOutB.tex;
    }
  }
  
  // final blit to screen (currentTex is final)
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0,0,canvas.width,canvas.height);
  
  // Clear the screen before drawing
  gl.clearColor(0, 0, 0, 1);
  gl.clear(gl.COLOR_BUFFER_BIT);
  
  // Always use transformed version for final output to enable zoom/pan controls
  gl.useProgram(progCompositeScreen);
  bindAttribs(progCompositeScreen);
  setTransformUniform(progCompositeScreen);
  gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, currentTex);
  gl.uniform1i(gl.getUniformLocation(progCompositeScreen,'u_base'), 0);
  gl.activeTexture(gl.TEXTURE1); gl.bindTexture(gl.TEXTURE_2D, texPool.tmp.tex);
  gl.uniform1i(gl.getUniformLocation(progCompositeScreen,'u_effect'), 1);
  gl.uniform1f(gl.getUniformLocation(progCompositeScreen,'u_amount'), 0.0);
  gl.uniform1i(gl.getUniformLocation(progCompositeScreen,'u_mode'), 0);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

// ------- UI building & bindings -------
function createNodeCard(node, idx){
  const card = document.createElement('div');
  card.className = 'node-card';
  // header
  const header = document.createElement('div'); header.className='node-header';
  const title = document.createElement('div'); title.className='node-title'; title.textContent = node.type;
  const headerRight = document.createElement('div'); headerRight.style.display='flex'; headerRight.style.gap='6px';
  // up/down buttons
  const up = document.createElement('button'); up.className='icon-btn'; up.innerHTML='‚Üë'; up.title='Move up';
  const down = document.createElement('button'); down.className='icon-btn'; down.innerHTML='‚Üì'; down.title='Move down';
  const toggleEnable = document.createElement('button'); toggleEnable.className='small-btn'; toggleEnable.textContent = node.enabled ? 'Enabled' : 'Disabled';
  const collapseBtn = document.createElement('button'); collapseBtn.className='small-btn'; collapseBtn.textContent = node.collapsed ? 'Expand' : 'Collapse';
  headerRight.appendChild(up); headerRight.appendChild(down); headerRight.appendChild(toggleEnable); headerRight.appendChild(collapseBtn);
  header.appendChild(title); header.appendChild(headerRight);
  card.appendChild(header);

  // order handlers
  up.addEventListener('click', ()=>{
    if(idx===0) return;
    const tmp = nodes[idx-1]; nodes[idx-1] = nodes[idx]; nodes[idx] = tmp;
    rebuildUI(); render();
  });
  down.addEventListener('click', ()=>{
    if(idx===nodes.length-1) return;
    const tmp = nodes[idx+1]; nodes[idx+1] = nodes[idx]; nodes[idx] = tmp;
    rebuildUI(); render();
  });

  toggleEnable.addEventListener('click', ()=>{
    node.enabled = !node.enabled;
    toggleEnable.textContent = node.enabled ? 'Enabled' : 'Disabled';
    render();
  });

  collapseBtn.addEventListener('click', ()=>{
    node.collapsed = !node.collapsed;
    collapseBtn.textContent = node.collapsed ? 'Expand' : 'Collapse';
    rebuildUI(); // easier to rebuild
  });

  // Node controls
  if(!node.collapsed){
    const controls = document.createElement('div'); controls.className='node-controls';
    // per-node before (bypass)
    const beforeRow = document.createElement('div'); beforeRow.className='control-row';
    const beforeLabel = document.createElement('label'); beforeLabel.textContent = 'Before / After (bypass this node)';
    const beforeBtn = document.createElement('button'); beforeBtn.className='small-btn'; beforeBtn.textContent = node.before ? 'Showing Before' : 'Showing After';
    beforeBtn.addEventListener('click', ()=>{ node.before = !node.before; beforeBtn.textContent = node.before ? 'Showing Before' : 'Showing After'; render(); });
    beforeRow.appendChild(beforeLabel); beforeRow.appendChild(beforeBtn);
    controls.appendChild(beforeRow);

    // Then node-specific settings
    if(node.type === 'Halation'){
      // Amount, Radius, Threshold, Color, Iterations
      controls.appendChild(makeRangeControl('Amount', node.settings, 'amount', 0, 2, 0.01));
      controls.appendChild(makeRangeControl('Radius (px)', node.settings, 'radius', 0, 200, 1));
      controls.appendChild(makeRangeControl('Threshold', node.settings, 'threshold', 0.5, 0.99, 0.01));
      controls.appendChild(makeColorControl('Color', node.settings, 'color'));
      controls.appendChild(makeRangeControl('Iterations', node.settings, 'iterations', 1, 4, 1));
    } else if(node.type === 'Glow'){
      // Amount, Radius, Threshold, Color, Iterations, Blend Mode, Resolve mode
      controls.appendChild(makeRangeControl('Amount', node.settings, 'amount', 0, 2, 0.01, true)); // show value
      controls.appendChild(makeRangeControl('Radius (px)', node.settings, 'radius', 0, 200, 1));
      controls.appendChild(makeRangeControl('Threshold', node.settings, 'threshold', 0.5, 0.99, 0.01));
      controls.appendChild(makeColorControl('Tint', node.settings, 'color'));
      controls.appendChild(makeRangeControl('Iterations', node.settings, 'iterations', 1, 4, 1));
      // blend mode select
      const blendRow = document.createElement('div'); blendRow.className='control-row';
      const blendLabel = document.createElement('label'); blendLabel.textContent = 'Blend Mode';
      const blendSelect = document.createElement('select');
      const blendOptions = ['Normal','Screen','Add','Overlay (Fast)','SoftLight (Fast)','Multiply','Overlay (Resolve)','SoftLight (Resolve)'];
      blendOptions.forEach(op=>{ const o=document.createElement('option'); o.value=o.textContent=op; blendSelect.appendChild(o); });
      blendSelect.value = node.settings.blend || 'Screen';
      blendSelect.addEventListener('change', ()=>{ node.settings.blend = blendSelect.value; render(); });
      blendRow.appendChild(blendLabel); blendRow.appendChild(blendSelect);
      controls.appendChild(blendRow);

      // Resolve Mode toggle
      const resolveRow = document.createElement('div'); resolveRow.className='control-row';
      const resolveLabel = document.createElement('label'); resolveLabel.textContent = 'Resolve Mode (enable to access Resolve-accurate Overlay/SoftLight)';
      const resolveBtn = document.createElement('button'); resolveBtn.className='small-btn'; resolveBtn.textContent = node.settings.resolveMode ? 'Resolve ON' : 'Resolve OFF';
      resolveBtn.addEventListener('click', ()=>{ node.settings.resolveMode = !node.settings.resolveMode; resolveBtn.textContent = node.settings.resolveMode ? 'Resolve ON' : 'Resolve OFF'; render(); });
      resolveRow.appendChild(resolveLabel); resolveRow.appendChild(resolveBtn);
      controls.appendChild(resolveRow);
    }
    card.appendChild(controls);
  }

  return card;
}

// helper creators
function makeRangeControl(labelText, settingsObj, key, min, max, step, showValue){
  const row = document.createElement('div'); row.className='control-row';
  const label = document.createElement('label'); label.textContent = labelText + (showValue ? ` ` : '');
  const range = document.createElement('input'); range.type='range'; range.min=min; range.max=max; range.step=step;
  range.value = settingsObj[key];
  const val = document.createElement('div'); val.className='tiny muted'; val.textContent = String(settingsObj[key]);
  range.addEventListener('input', ()=>{ settingsObj[key] = range.value; val.textContent = String(range.value); render(); });
  row.appendChild(label); row.appendChild(range); if(showValue) row.appendChild(val);
  return row;
}
function makeColorControl(labelText, settingsObj, key){
  const row = document.createElement('div'); row.className='control-row';
  const label = document.createElement('label'); label.textContent = labelText;
  const inp = document.createElement('input'); inp.type='color'; inp.value = settingsObj[key];
  inp.addEventListener('input', ()=>{ settingsObj[key] = inp.value; render(); });
  row.appendChild(label); row.appendChild(inp);
  return row;
}

function rebuildUI(){
  nodesContainer.innerHTML = '';
  for(let i=0;i<nodes.length;i++){
    const card = createNodeCard(nodes[i], i);
    nodesContainer.appendChild(card);
  }
}

// initial UI build
rebuildUI();

// ------- Image upload & texture creation -------
function uploadImageToGL(img){
  // resample and preserve aspect to canvas internal pixel size
  fitCanvas();
  // Remember original image and its native resolution for high-res export
  originalImage = img;
  originalImageWidth = img.naturalWidth || img.width;
  originalImageHeight = img.naturalHeight || img.height;
  const w = canvas.width, h = canvas.height;
  const off = document.createElement('canvas'); off.width = w; off.height = h;
  const ctx = off.getContext('2d');
  ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h);
  const ia = img.width / img.height, ca = w / h;
  let dw, dh, dx, dy;
  if(ia > ca){ dw = w; dh = Math.round(w / ia); dx = 0; dy = Math.round((h - dh)/2); }
  else { dh = h; dw = Math.round(h * ia); dy = 0; dx = Math.round((w - dw)/2); }
  ctx.drawImage(img, dx, dy, dw, dh);
  imageRect = { dx: dx, dy: dy, dw: dw, dh: dh, canvasW: w, canvasH: h };
  // upload to GL texture
  if(sourceTex) try{ gl.deleteTexture(sourceTex); } catch(e){}
  sourceTex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, sourceTex);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, off);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  initPool(); // recreate FBO pool sized to canvas dims
  render();
}

// ------- render loop -------
function render(){
  // ensure pool exists and matches canvas
  if(!texPool.nodeOutA) initPool();
  runPipelineAndDraw();
}

// ------- file handlers & UI ----------
fileInput.addEventListener('change', (e)=>{
  const f = e.target.files[0]; if(!f) return;
  const img = new Image();
  img.onload = ()=>{ uploadImageToGL(img); };
  img.src = URL.createObjectURL(f);
});
fitBtn.addEventListener('click', ()=>{ render(); });

// Download crop to imageRect
downloadBtn.addEventListener('click', ()=>{
  // If we have the original image, render the full pipeline at its native resolution for export
  if(originalImage && originalImageWidth>0 && originalImageHeight>0){
    // Save current UI/GL state
    const prevCssW = canvas.style.width;
    const prevCssH = canvas.style.height;
    const prevW = canvas.width;
    const prevH = canvas.height;
    const prevImageRect = imageRect ? { ...imageRect } : null;
    const savedTransform = { ...canvasTransform };
    const savedNodes = JSON.parse(JSON.stringify(nodes));

    // Resize canvas to original resolution (no CSS change to avoid layout shift)
    canvas.width = originalImageWidth;
    canvas.height = originalImageHeight;
    initPool();

    // Rebuild source texture from original image at full resolution (no letterboxing)
    const off = document.createElement('canvas');
    off.width = originalImageWidth; off.height = originalImageHeight;
    const offCtx = off.getContext('2d');
    offCtx.drawImage(originalImage, 0, 0, originalImageWidth, originalImageHeight);

    if(sourceTex) { try{ gl.deleteTexture(sourceTex); }catch(e){} }
    sourceTex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, sourceTex);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, off);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    // Image now fills the canvas entirely
    imageRect = { dx:0, dy:0, dw: originalImageWidth, dh: originalImageHeight, canvasW: originalImageWidth, canvasH: originalImageHeight };

    // Reset view transform (no zoom/pan in export)
    canvasTransform.scale = 1.0;
    canvasTransform.translateX = 0.0;
    canvasTransform.translateY = 0.0;

    // Scale pixel-based radii to maintain perceived look relative to image size
    const radiusScale = (prevImageRect && prevImageRect.dw>0) ? (originalImageWidth / prevImageRect.dw) : 1.0;
    nodes.forEach(n=>{
      if(n && n.settings && typeof n.settings.radius !== 'undefined'){
        n.settings.radius = parseFloat(n.settings.radius) * radiusScale;
      }
    });

    // Render at high resolution
    render();

    // Read the image directly from the canvas at full resolution
    canvas.toBlob(blob=>{
      // Restore previous state immediately after we have the blob
      // Restore nodes
      nodes = savedNodes;
      // Restore canvas size and style, and re-upload fitted source for UI
      canvas.width = prevW; canvas.height = prevH; canvas.style.width = prevCssW; canvas.style.height = prevCssH;
      // Restore transform
      canvasTransform.scale = savedTransform.scale;
      canvasTransform.translateX = savedTransform.translateX;
      canvasTransform.translateY = savedTransform.translateY;
      // Recreate original working textures and imageRect by refitting the original image
      uploadImageToGL(originalImage);
      // Rebuild UI to reflect restored settings
      rebuildUI();
      render();

      // Trigger download
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download='halation-node.png'; a.click();
      URL.revokeObjectURL(url);
    }, 'image/png');
  } else {
    // Fallback: download current canvas
    const url = canvas.toDataURL();
    const a=document.createElement('a'); a.href=url; a.download='halation-node.png'; a.click();
  }
});

// ------- Touch Controls -------
function resetView() {
  canvasTransform.scale = 1.0;
  canvasTransform.translateX = 0.0;
  canvasTransform.translateY = 0.0;
  console.log('Reset view:', canvasTransform);
  render();
}

function zoomIn() {
  canvasTransform.scale = Math.min(canvasTransform.scale * 1.2, canvasTransform.maxScale);
  console.log('Zoom in:', canvasTransform.scale);
  render();
}

function zoomOut() {
  canvasTransform.scale = Math.max(canvasTransform.scale / 1.2, canvasTransform.minScale);
  console.log('Zoom out:', canvasTransform.scale);
  render();
}

function getTouchDistance(touches) {
  if (touches.length < 2) return 0;
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

function getTouchCenter(touches) {
  if (touches.length === 0) return { x: 0, y: 0 };
  let x = 0, y = 0;
  for (let i = 0; i < touches.length; i++) {
    x += touches[i].clientX;
    y += touches[i].clientY;
  }
  return { x: x / touches.length, y: y / touches.length };
}

// Touch event handlers
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  const touches = Array.from(e.touches);
  console.log('Touch start:', touches.length, 'touches');
  
  if (touches.length === 1) {
    // Single touch - start dragging
    touchState.isDragging = true;
    touchState.lastTouchX = touches[0].clientX;
    touchState.lastTouchY = touches[0].clientY;
  } else if (touches.length === 2) {
    // Two touches - start pinch to zoom
    touchState.startDistance = getTouchDistance(touches);
    touchState.startScale = canvasTransform.scale;
  }
});

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const touches = Array.from(e.touches);
  
  if (touches.length === 1 && touchState.isDragging) {
    // Single touch drag
    const deltaX = touches[0].clientX - touchState.lastTouchX;
    const deltaY = touches[0].clientY - touchState.lastTouchY;
    
    canvasTransform.translateX += deltaX;
    canvasTransform.translateY += deltaY;
    
    touchState.lastTouchX = touches[0].clientX;
    touchState.lastTouchY = touches[0].clientY;
    
    render();
  } else if (touches.length === 2) {
    // Two touch pinch to zoom
    const currentDistance = getTouchDistance(touches);
    if (touchState.startDistance > 0) {
      const scaleFactor = currentDistance / touchState.startDistance;
      const newScale = touchState.startScale * scaleFactor;
      canvasTransform.scale = Math.max(canvasTransform.minScale, 
                                     Math.min(canvasTransform.maxScale, newScale));
      render();
    }
  }
});

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  touchState.isDragging = false;
  touchState.startDistance = 0;
});

// Mouse controls for desktop
canvas.addEventListener('mousedown', (e) => {
  if (e.button === 0) { // Left mouse button
    touchState.isDragging = true;
    touchState.lastTouchX = e.clientX;
    touchState.lastTouchY = e.clientY;
    canvas.style.cursor = 'grabbing';
    console.log('Mouse down - start dragging');
  }
});

canvas.addEventListener('mousemove', (e) => {
  if (touchState.isDragging) {
    const deltaX = e.clientX - touchState.lastTouchX;
    const deltaY = e.clientY - touchState.lastTouchY;
    
    canvasTransform.translateX += deltaX;
    canvasTransform.translateY += deltaY;
    
    touchState.lastTouchX = e.clientX;
    touchState.lastTouchY = e.clientY;
    
    render();
  }
});

canvas.addEventListener('mouseup', (e) => {
  touchState.isDragging = false;
  canvas.style.cursor = 'grab';
});

canvas.addEventListener('mouseleave', (e) => {
  touchState.isDragging = false;
  canvas.style.cursor = 'grab';
});

canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
  canvasTransform.scale = Math.max(canvasTransform.minScale, 
                                 Math.min(canvasTransform.maxScale, 
                                        canvasTransform.scale * zoomFactor));
  render();
});

// Touch control button handlers
$('zoomInBtn').addEventListener('click', zoomIn);
$('zoomOutBtn').addEventListener('click', zoomOut);
$('resetViewBtn').addEventListener('click', resetView);

// initial blank render
render();

</script>
</body>
</html>
